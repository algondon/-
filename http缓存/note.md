## web性能的优化
1. dom加载原理，从而引出css放前面，js放后面或者合理利用defer,async
2. 并行下载是有代价的（下载速度慢）,所以要合并css,js,也要对其压缩，可以通过webpack打包压缩。
3. 小图标的加载采用雪碧图，通过控制图片的background-position实现不同图标的显示
4. 大图片可以采用webp的方式，这种方式我没有实践，但是据说webp体积小，清晰度高
5. 将文件放到cdn上，能够一定程度上提高客户端下载速度
6. cdn不稳定的话，就只能通过合理的利用Http缓存了。
7. 其实，通过h5的manifest和http缓存配合使用，个人认为效果更佳
8. 合理利用ajax的缓存，这里不是很清楚，还有点问题

## http缓存的重要性
合理利用缓存，能够极大的减小服务器压力，极大的提升客户端体验

## 如何合理利用
1. 不会修改的静态资源采用强缓存的方式
2. 会发生修改的文件js,css等，采用协商缓存的方式

## 关键头部
1. 强缓存
    Cache-Control,Expires,Cache-Control优先级高，采用的是相对时间，效果好
2. 协商缓存
    Last-Modified(server),if-modified-since(client)配合使用,客户端不需要人为配置，浏览器检测到服务端设置Last-Modified之后就会在下次请求发送if-modified-since，服务器端比较两个时间来决定发送新的回应还是发送304，让浏览器使用本地缓存，但是有可能资源已经改变，而服务器并没有检测到，从而导致资源得不到及时更新。
    Etag(server),if-none-match(client),同样的，客户端不需要人为配置，浏览器检测到服务器端Etag的设置，会自动在下次请求头部添加if-none-match,内容就是上次发送的Etag,服务端进行对比从而决定发送304，还是重新发送新的资源。Etag是根据文件名，最后修改时间，以及文件的大小以及每个机器的不同ip,物理地址等地址生成的独一无二的字符串，所以修改时间，文件大小发生了改变，都会导致Etag的不同，从而及时更新信息。 **但是要注意，Etag跟计算机的信息有关，所以如果是分布式服务器，务必取消Etag，采用last-modified,同时还要保证多个服务器的last-modified相同**

## 还有什么办法能达到相同的效果
我认为，h5的minifest文件也可以做到相同的效果，同时，服务器通过版本号来控制静态资源的更新，很好用的一个特性，但是所有资源的更新与否都根据一个manifest版本号来控制，会导致没有修改的静态文件的重新加载，这个时候如果配合http缓存，个人认为效果能好很多

## 怎么配合
manifest的原理是这样的：第一次访问，浏览器根据manifest文件下载相应的文件，放入缓存，第二次访问，先发送一个请求，查询其版本号是否与当前不同，如果不同，重新从服务器下载文件，如果相同，使用之前缓存的文件。
这里面其实有一个可以利用的地方，就是如果版本号不同，重新向服务器发送请求进而缓存文件，这个时候，服务器端可以采用强缓存或者协商缓存，来决定是否要返回新的文件还是让浏览器沿用之前的缓存。从而达到版本号更改，需要替换的文件依旧采用强缓存和协商缓存的方式来实现合理的利用之前的缓存
